// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Jwt_bearerScopes = "jwt_bearer.Scopes"
)

// Defines values for AbstractExchangeType.
const (
	AbstractExchangeTypeReqRespPair AbstractExchangeType = "reqRespPair"
	AbstractExchangeTypeUnidirEvent AbstractExchangeType = "unidirEvent"
)

// Defines values for BindingType.
const (
	AMQP         BindingType = "AMQP"
	GOOGLEPUBSUB BindingType = "GOOGLEPUBSUB"
	KAFKA        BindingType = "KAFKA"
	MQTT         BindingType = "MQTT"
	NATS         BindingType = "NATS"
	WS           BindingType = "WS"
)

// Defines values for OAuth2GrantType.
const (
	CLIENTCREDENTIALS OAuth2GrantType = "CLIENT_CREDENTIALS"
	PASSWORD          OAuth2GrantType = "PASSWORD"
	REFRESHTOKEN      OAuth2GrantType = "REFRESH_TOKEN"
)

// Defines values for ParameterConstraintIn.
const (
	ParameterConstraintInHeader ParameterConstraintIn = "header"
	ParameterConstraintInPath   ParameterConstraintIn = "path"
	ParameterConstraintInQuery  ParameterConstraintIn = "query"
)

// Defines values for RequestResponsePairType.
const (
	RequestResponsePairTypeReqRespPair RequestResponsePairType = "reqRespPair"
	RequestResponsePairTypeUnidirEvent RequestResponsePairType = "unidirEvent"
)

// Defines values for ResourceType.
const (
	ResourceTypeASYNCAPISCHEMA      ResourceType = "ASYNC_API_SCHEMA"
	ResourceTypeASYNCAPISPEC        ResourceType = "ASYNC_API_SPEC"
	ResourceTypeAVROSCHEMA          ResourceType = "AVRO_SCHEMA"
	ResourceTypeGRAPHQLSCHEMA       ResourceType = "GRAPHQL_SCHEMA"
	ResourceTypeJSONSCHEMA          ResourceType = "JSON_SCHEMA"
	ResourceTypeOPENAPISCHEMA       ResourceType = "OPEN_API_SCHEMA"
	ResourceTypeOPENAPISPEC         ResourceType = "OPEN_API_SPEC"
	ResourceTypePOSTMANCOLLECTION   ResourceType = "POSTMAN_COLLECTION"
	ResourceTypePROTOBUFDESCRIPTION ResourceType = "PROTOBUF_DESCRIPTION"
	ResourceTypePROTOBUFSCHEMA      ResourceType = "PROTOBUF_SCHEMA"
	ResourceTypeWSDL                ResourceType = "WSDL"
	ResourceTypeXSD                 ResourceType = "XSD"
)

// Defines values for ServiceType.
const (
	EVENT        ServiceType = "EVENT"
	GENERICEVENT ServiceType = "GENERIC_EVENT"
	GENERICREST  ServiceType = "GENERIC_REST"
	GRAPHQL      ServiceType = "GRAPHQL"
	GRPC         ServiceType = "GRPC"
	REST         ServiceType = "REST"
	SOAPHTTP     ServiceType = "SOAP_HTTP"
)

// Defines values for TestRunnerType.
const (
	TestRunnerTypeASYNCAPISCHEMA TestRunnerType = "ASYNC_API_SCHEMA"
	TestRunnerTypeGRAPHQLSCHEMA  TestRunnerType = "GRAPHQL_SCHEMA"
	TestRunnerTypeGRPCPROTOBUF   TestRunnerType = "GRPC_PROTOBUF"
	TestRunnerTypeHTTP           TestRunnerType = "HTTP"
	TestRunnerTypeOPENAPISCHEMA  TestRunnerType = "OPEN_API_SCHEMA"
	TestRunnerTypePOSTMAN        TestRunnerType = "POSTMAN"
	TestRunnerTypeSOAPHTTP       TestRunnerType = "SOAP_HTTP"
	TestRunnerTypeSOAPUI         TestRunnerType = "SOAP_UI"
)

// Defines values for Trend.
const (
	DOWN    Trend = "DOWN"
	LOWDOWN Trend = "LOW_DOWN"
	LOWUP   Trend = "LOW_UP"
	STABLE  Trend = "STABLE"
	UP      Trend = "UP"
)

// Defines values for UnidirectionalEventType.
const (
	ReqRespPair UnidirectionalEventType = "reqRespPair"
	UnidirEvent UnidirectionalEventType = "unidirEvent"
)

// AbstractExchange Abstract bean representing a Service or API Exchange.
type AbstractExchange struct {
	// Type Discriminant type for identifying kind of exchange
	Type AbstractExchangeType `json:"type"`
}

// AbstractExchangeType Discriminant type for identifying kind of exchange
type AbstractExchangeType string

// ArtifactDownload Artifact Download specification to be imported by Microcks.
type ArtifactDownload struct {
	// MainArtifact Whether this remote artifact should be imported as main/primary or secondary artifact. Default is true.
	MainArtifact *bool `json:"mainArtifact,omitempty"`

	// SecretName The name of a secret that can be used to authenticated when downloading remote artifact.
	SecretName *string `json:"secretName,omitempty"`

	// Url The URL of remote artifact to download and import
	Url string `json:"url"`
}

// ArtifactUpload Artifact to be imported by Microcks.
// This structure represents a mime-multipart file upload (as specified here: https://swagger.io/docs/specification/describing-request-body/file-upload/)
type ArtifactUpload struct {
	// File The artifact to upload
	File openapi_types.File `json:"file"`
}

// Binding Protocol binding details for asynchronous operations
type Binding struct {
	// DestinationName Name of destination for asynchronous messages of this operation
	DestinationName string `json:"destinationName"`

	// DestinationType Type of destination for asynchronous messages of this operation
	DestinationType *string `json:"destinationType,omitempty"`

	// KeyType Type of key for Kafka messages
	KeyType *string `json:"keyType,omitempty"`

	// Method HTTP method for WebSocket binding
	Method *string `json:"method,omitempty"`

	// Persistent Persistent attribute for MQTT binding
	Persistent *bool `json:"persistent,omitempty"`

	// QoS Quality of Service attribute for MQTT binding
	QoS *string `json:"qoS,omitempty"`

	// Type Protocol binding identifier
	Type BindingType `json:"type"`
}

// BindingType Protocol binding identifier
type BindingType string

// Counter A simple Counter type.
type Counter struct {
	// Counter Number of items in a resource collection
	Counter *int32 `json:"counter,omitempty"`
}

// CounterMap A generic map of counter
type CounterMap map[string]float32

// DailyInvocationStatistic The daily statistic of a service mock invocations
type DailyInvocationStatistic struct {
	// DailyCount The number of service mock invocations on this day
	DailyCount float32 `json:"dailyCount"`

	// Day The day (formatted as yyyyMMdd string) represented by this statistic
	Day string `json:"day"`

	// HourlyCount The number of service mock invocations per hour of the day (keys range from 0 to 23)
	HourlyCount *map[string]interface{} `json:"hourlyCount,omitempty"`

	// Id Unique identifier of this statistic object
	Id string `json:"id"`

	// MinuteCount The number of service mock invocations per minute of the day (keys range from 0 to 1439)
	MinuteCount *map[string]interface{} `json:"minuteCount,omitempty"`

	// ServiceName The name of the service this statistic is related to
	ServiceName string `json:"serviceName"`

	// ServiceVersion The version of the service this statistic is related to
	ServiceVersion string `json:"serviceVersion"`
}

// EventMessage defines model for EventMessage.
type EventMessage struct {
	// Content Body content for this message
	Content *string `json:"content,omitempty"`

	// DispatchCriteria Dispatch criteria of this message (in case of a mock)
	DispatchCriteria *string `json:"dispatchCriteria,omitempty"`

	// Headers Headers for this message
	Headers *[]Header `json:"headers,omitempty"`

	// Id Unique identifier of this message
	Id string `json:"id"`

	// MediaType Content type of message
	MediaType string `json:"mediaType"`

	// Name Unique distinct name of this message
	Name string `json:"name"`

	// OperationId Identifier of Operation this message is associated to
	OperationId string `json:"operationId"`

	// TestCaseId Unique identifier of TestCase this message is attached (in case of a test)
	TestCaseId *string `json:"testCaseId,omitempty"`
}

// Exchange Abstract representation of a Service or API exchange type (request/response, event based, ...)
type Exchange struct {
	union json.RawMessage
}

// Header Transport headers for both Requests and Responses
type Header struct {
	// Name Unique distinct name of this Header
	Name string `json:"name"`

	// Values Values for this Header
	Values []string `json:"values"`
}

// HeaderDTO Data Transfert Object for headers of both Requests and Responses
type HeaderDTO struct {
	// Name Unique distinct name of this Header
	Name string `json:"name"`

	// Values Values for this header (comma separated strings)
	Values string `json:"values"`
}

// ImportJob An ImportJob allow defining a repository artifact to poll for discovering Services and APIs mocks and tests
type ImportJob struct {
	// Active Whether this ImportJob is active (ie. scheduled for execution)
	Active *bool `json:"active,omitempty"`

	// CreatedDate Creation timestamp for this ImportJob
	CreatedDate *int64 `json:"createdDate,omitempty"`

	// Etag Etag of repository URL during previous import. Is used for not re-importing if no recent changes
	Etag *string `json:"etag,omitempty"`

	// Frequency Reserved for future usage
	Frequency *string `json:"frequency,omitempty"`

	// Id Unique identifier of ImportJob
	Id *string `json:"id,omitempty"`

	// LastImportDate Timestamp of the last import
	LastImportDate *int64 `json:"lastImportDate,omitempty"`

	// LastImportError Error message of last import (if any)
	LastImportError *string `json:"lastImportError,omitempty"`

	// MainArtifact Flag telling if considered as primary or secondary artifact. Default to `true`
	MainArtifact *bool `json:"mainArtifact,omitempty"`

	// Metadata Commodity object for holding metadata on any entity. This object is inspired by Kubernetes metadata.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name Unique distinct name of this ImportJob
	Name string `json:"name"`

	// RepositoryDisableSSLValidation Whether to disable SSL certificate verification when checking repository
	RepositoryDisableSSLValidation *bool `json:"repositoryDisableSSLValidation,omitempty"`

	// RepositoryUrl URL of mocks and tests repository artifact
	RepositoryUrl string `json:"repositoryUrl"`

	// SecretRef Lightweight reference for an existing Secret
	SecretRef *SecretRef `json:"secretRef,omitempty"`

	// ServiceRefs References of Services discovered when checking repository
	ServiceRefs *[]ServiceRef `json:"serviceRefs,omitempty"`
}

// KeycloakConfig Representation of Keycloak / SSO configuration used by Microcks server
type KeycloakConfig struct {
	// AuthServerUrl SSO Server authentication url
	AuthServerUrl string `json:"auth-server-url"`

	// Enabled Whether Keycloak authentification and usage is enabled
	Enabled bool `json:"enabled"`

	// PublicClient Name of public-client that can be used for requesting OAuth token
	PublicClient bool `json:"public-client"`

	// Realm Authentication realm name
	Realm string `json:"realm"`

	// Resource Name of Keycloak resource/application used on client side
	Resource string `json:"resource"`

	// SslRequired SSL certificates requirements
	SslRequired interface{} `json:"ssl-required"`
}

// LabelsMap A map which keys are already used labels keys and values are already used values for this key
type LabelsMap map[string]StringArray

// Message Common structure for Request, Response and EventMessage
type Message struct {
	// Content Body content for this message
	Content *string `json:"content,omitempty"`

	// Headers Headers for this message
	Headers *[]Header `json:"headers,omitempty"`

	// Id Unique identifier of this message
	Id *string `json:"id,omitempty"`

	// Name Unique distinct name of this message
	Name string `json:"name"`

	// OperationId Identifier of Operation this message is associated to
	OperationId string `json:"operationId"`

	// TestCaseId Unique identifier of TestCase this message is attached (in case of a test)
	TestCaseId *string `json:"testCaseId,omitempty"`
}

// MessageArray Array of Exchanges for Service operations
type MessageArray = []Exchange

// Metadata Commodity object for holding metadata on any entity. This object is inspired by Kubernetes metadata.
type Metadata struct {
	// Annotations Annotations of attached object
	Annotations *map[string]string `json:"annotations,omitempty"`

	// CreatedOn Creation date of attached object
	CreatedOn *float32 `json:"createdOn,omitempty"`

	// Labels Labels put on attached object
	Labels *map[string]string `json:"labels,omitempty"`

	// LastUpdate Last update of attached object
	LastUpdate *float32 `json:"lastUpdate,omitempty"`
}

// OAuth2AuthorizedClient OAuth2 authorized client that performed a test
type OAuth2AuthorizedClient struct {
	// GrantType Enumeration for the different supported grants/flows of OAuth2
	GrantType OAuth2GrantType `json:"grantType"`

	// PrincipalName Name of authorized principal (clientId or username in the case of Password grant type)
	PrincipalName string `json:"principalName"`

	// Scopes Included scopes (separated using space)
	Scopes *string `json:"scopes,omitempty"`

	// TokenUri Identity Provider URI used for token retrieval
	TokenUri string `json:"tokenUri"`
}

// OAuth2ClientContent Represents a volatile OAuth2 client context usually associated with a Test request
type OAuth2ClientContent struct {
	// ClientId Id for connecting to OAuth2 identity provider
	ClientId string `json:"clientId"`

	// ClientSecret Secret for connecting to OAuth2 identity provider
	ClientSecret string `json:"clientSecret"`

	// Password User password in case you're suing the Resource Owner password flow
	Password *string `json:"password,omitempty"`

	// RefreshToken Refresh token in case you're using the Refresh Token rotation flow
	RefreshToken *string `json:"refreshToken,omitempty"`

	// TokenUri URI for retrieving an access token from OAuth2 identity provider
	TokenUri string `json:"tokenUri"`

	// Username Username in case you're using the Resource Owner Password flow
	Username *string `json:"username,omitempty"`
}

// OAuth2GrantType Enumeration for the different supported grants/flows of OAuth2
type OAuth2GrantType string

// Operation An Operation of a Service or API
type Operation struct {
	// Bindings Map of protocol binding details for this operation
	Bindings *map[string]Binding `json:"bindings,omitempty"`

	// DefaultDelay Default response time delay for mocks
	DefaultDelay *float32 `json:"defaultDelay,omitempty"`

	// Dispatcher Dispatcher strategy used for mocks
	Dispatcher *string `json:"dispatcher,omitempty"`

	// DispatcherRules DispatcherRules used for mocks
	DispatcherRules *string `json:"dispatcherRules,omitempty"`

	// InputName Name of input parameters in case of Xml based Service
	InputName *string `json:"inputName,omitempty"`

	// Method Represents transport method
	Method string `json:"method"`

	// Name Unique name of this Operation within Service scope
	Name string `json:"name"`

	// OutputName Name of output parameters in case of Xml based Service
	OutputName *string `json:"outputName,omitempty"`

	// ParameterContraints Contraints that may apply to mock invocatino on this operation
	ParameterContraints *[]ParameterConstraint `json:"parameterContraints,omitempty"`

	// ResourcePaths Paths the mocks endpoints are mapped on
	ResourcePaths *[]string `json:"resourcePaths,omitempty"`
}

// OperationHeaders Specification of additional headers for a Service/API operations. Keys are operation name or "globals" (if header applies to all), values are Header objects DTO.
type OperationHeaders map[string][]HeaderDTO

// OperationOverrideDTO Data Transfer object for grouping the mutable properties of an Operation
type OperationOverrideDTO struct {
	// DefaultDelay Default delay in milliseconds to apply to mock responses on this operation
	DefaultDelay *int `json:"defaultDelay,omitempty"`

	// Dispatcher Type of dispatcher to apply for this operation
	Dispatcher *string `json:"dispatcher,omitempty"`

	// DispatcherRules Rules of dispatcher for this operation
	DispatcherRules *string `json:"dispatcherRules,omitempty"`

	// ParameterConstraints Constraints that may apply to incoming parameters on this operation
	ParameterConstraints *[]ParameterConstraint `json:"parameterConstraints,omitempty"`
}

// Parameter Companion objects for Request representing query parameter
type Parameter struct {
	// Name The name of the parameter
	Name string `json:"name"`

	// Value The value of this parameter
	Value string `json:"value"`
}

// ParameterConstraint Companion object for Operation that may be used to express constraints on request parameters
type ParameterConstraint struct {
	// In Parameter location
	In *ParameterConstraintIn `json:"in,omitempty"`

	// MustMatchRegexp Whether it's a regular expression matching constraint
	MustMatchRegexp *string `json:"mustMatchRegexp,omitempty"`

	// Name Parameter name
	Name string `json:"name"`

	// Recopy Whether it's a recopy constraint
	Recopy *bool `json:"recopy,omitempty"`

	// Required Whether it's a required constraint
	Required *bool `json:"required,omitempty"`
}

// ParameterConstraintIn Parameter location
type ParameterConstraintIn string

// Request defines model for Request.
type Request struct {
	// Content Body content for this message
	Content *string `json:"content,omitempty"`

	// Headers Headers for this message
	Headers *[]Header `json:"headers,omitempty"`

	// Id Unique identifier of this message
	Id *string `json:"id,omitempty"`

	// Name Unique distinct name of this message
	Name string `json:"name"`

	// OperationId Identifier of Operation this message is associated to
	OperationId string `json:"operationId"`

	// QueryParameters Query parameters for this Request if any
	QueryParameters *[]Parameter `json:"queryParameters,omitempty"`

	// ResponseId Unique identifier of Response this Request is attached
	ResponseId *string `json:"responseId,omitempty"`

	// TestCaseId Unique identifier of TestCase this message is attached (in case of a test)
	TestCaseId *string `json:"testCaseId,omitempty"`
}

// RequestResponsePair defines model for RequestResponsePair.
type RequestResponsePair struct {
	// Request A mock invocation or test request
	Request Request `json:"request"`

	// Response A mock invocation or test response
	Response Response `json:"response"`

	// Type Discriminant type for identifying kind of exchange
	Type RequestResponsePairType `json:"type"`
}

// RequestResponsePairType Discriminant type for identifying kind of exchange
type RequestResponsePairType string

// Resource Resource represents a Service or API artifacts such as specification, contract
type Resource struct {
	// Content String content of this resource
	Content string `json:"content"`

	// Id Uniquer identifier of this Service or API Resource
	Id string `json:"id"`

	// Name Unique name/business identifier for this Service or API resource
	Name string `json:"name"`

	// Path Relative path of this resource regarding main resource
	Path *string `json:"path,omitempty"`

	// ServiceId Unique identifier of the Servoce or API this resource is attached to
	ServiceId string `json:"serviceId"`

	// SourceArtifact Short name of the artifact this resource was extracted from
	SourceArtifact *string `json:"sourceArtifact,omitempty"`

	// Type Types of managed resources for Services or APIs
	Type ResourceType `json:"type"`
}

// ResourceType Types of managed resources for Services or APIs
type ResourceType string

// Response defines model for Response.
type Response struct {
	// Content Body content for this message
	Content *string `json:"content,omitempty"`

	// DispatchCriteria Dispatch criteria of this Response (in case of a mock)
	DispatchCriteria *string `json:"dispatchCriteria,omitempty"`

	// Headers Headers for this message
	Headers *[]Header `json:"headers,omitempty"`

	// Id Unique identifier of this message
	Id *string `json:"id,omitempty"`

	// IsFault Whether this Response represents a Fault
	IsFault *bool `json:"isFault,omitempty"`

	// MediaType Content type of this Response
	MediaType *string `json:"mediaType,omitempty"`

	// Name Unique distinct name of this message
	Name string `json:"name"`

	// OperationId Identifier of Operation this message is associated to
	OperationId string `json:"operationId"`

	// Status Status of this Response
	Status *string `json:"status,omitempty"`

	// TestCaseId Unique identifier of TestCase this message is attached (in case of a test)
	TestCaseId *string `json:"testCaseId,omitempty"`
}

// Secret A Secret allows grouping informations on how to access a restricted resource such as a repsoitory URL. Secrets are typically used by ImpoortJobs.
type Secret struct {
	CaCertPem *string `json:"caCertPem,omitempty"`

	// Description Description of this Secret
	Description string `json:"description"`

	// Id Unique identifier of Secret
	Id *string `json:"id,omitempty"`

	// Name Unique distinct name of Secret
	Name        string  `json:"name"`
	Password    *string `json:"password,omitempty"`
	Token       *string `json:"token,omitempty"`
	TokenHeader *string `json:"tokenHeader,omitempty"`
	Username    *string `json:"username,omitempty"`
}

// SecretRef Lightweight reference for an existing Secret
type SecretRef struct {
	// Name Distinct name of the referenced Secret
	Name string `json:"name"`

	// SecretId Unique identifier or referenced Secret
	SecretId string `json:"secretId"`
}

// Service Represents a Service or API definition as registred into Microcks repository
type Service struct {
	// Id Unique identifier for this Service or API
	Id *string `json:"id,omitempty"`

	// Metadata Commodity object for holding metadata on any entity. This object is inspired by Kubernetes metadata.
	Metadata *Metadata `json:"metadata,omitempty"`

	// Name Distinct name for this Service or API (maybe shared among many versions)
	Name string `json:"name"`

	// Operations Set of Operations for Service or API
	Operations *[]Operation `json:"operations,omitempty"`

	// SourceArtifact Short name of the main/primary artifact this service was created from
	SourceArtifact string `json:"sourceArtifact"`

	// Type Service or API Type
	Type ServiceType `json:"type"`

	// Version Distinct version for a named Service or API
	Version string `json:"version"`

	// XmlNS Associated Xml Namespace in case of Xml based Service
	XmlNS *string `json:"xmlNS,omitempty"`
}

// ServiceType Service or API Type
type ServiceType string

// ServiceRef Lightweight reference of an existing Service
type ServiceRef struct {
	// Name The Service name
	Name string `json:"name"`

	// ServiceId Unique reference of a Service
	ServiceId string `json:"serviceId"`

	// Version The Service version
	Version string `json:"version"`
}

// ServiceView Aggregate bean for grouping a Service an its messages pairs
type ServiceView struct {
	// MessagesMap Map of messages for this Service. Keys are operation name, values are array of messages for this operation
	MessagesMap map[string]MessageArray `json:"messagesMap"`

	// Service Represents a Service or API definition as registred into Microcks repository
	Service Service `json:"service"`
}

// SnapshotUpload Upload of a repository snapshot file
type SnapshotUpload struct {
	// File The repository snapshot file
	File openapi_types.File `json:"file"`
}

// StringArray A simple array of String
type StringArray = []string

// TestCaseResult Companion objects for TestResult. Each TestCaseResult correspond to a particuliar service operation / action reference by the operationName field. TestCaseResults owns a collection of TestStepResults (one for every request associated to service operation / action).
type TestCaseResult struct {
	// ElapsedTime Elapsed time in milliseconds since the test case beginning
	ElapsedTime float32 `json:"elapsedTime"`

	// OperationName Name of operation this test case is bound to
	OperationName string `json:"operationName"`

	// Success Flag telling if test case is a success
	Success bool `json:"success"`

	// TestStepResults Test steps associated to this test case
	TestStepResults *[]TestStepResult `json:"testStepResults,omitempty"`
}

// TestCaseReturnDTO defines model for TestCaseReturnDTO.
type TestCaseReturnDTO struct {
	// OperationName Name of related operation for this TestCase
	OperationName string `json:"operationName"`
}

// TestConformanceMetric Represents the test conformance metrics (current score, history and evolution trend) of a Service
type TestConformanceMetric struct {
	// AggregationLabelValue Value of the label used for metrics aggregation (if any)
	AggregationLabelValue *string `json:"aggregationLabelValue,omitempty"`

	// CurrentScore Current test conformance score for the related Service
	CurrentScore float64 `json:"currentScore"`

	// Id Unique identifier of coverage metric
	Id string `json:"id"`

	// LastUpdateDay The day of latest score update (in yyyyMMdd format)
	LastUpdateDay *string `json:"lastUpdateDay,omitempty"`

	// LatestScores History of latest scores (key is date with format yyyyMMdd, value is score as double)
	LatestScores *map[string]float32 `json:"latestScores,omitempty"`

	// LatestTrend Evolution trend qualifier
	LatestTrend *Trend `json:"latestTrend,omitempty"`

	// MaxPossibleScore Maximum conformance score that can be reached (depends on samples expresiveness)
	MaxPossibleScore float64 `json:"maxPossibleScore"`

	// ServiceId Unique identifier of the Service this metric is related to
	ServiceId string `json:"serviceId"`
}

// TestRequest Test request is a minimalist wrapper for requesting the launch of a new test
type TestRequest struct {
	// FilteredOperations A restriction on service operations to test
	FilteredOperations *[]string `json:"filteredOperations,omitempty"`

	// OAuth2Context Represents a volatile OAuth2 client context usually associated with a Test request
	OAuth2Context *OAuth2ClientContent `json:"oAuth2Context,omitempty"`

	// OperationsHeaders Specification of additional headers for a Service/API operations. Keys are operation name or "globals" (if header applies to all), values are Header objects DTO.
	OperationsHeaders *OperationHeaders `json:"operationsHeaders,omitempty"`

	// RunnerType Type of test strategy (different strategies are implemented by different runners)
	RunnerType TestRunnerType `json:"runnerType"`

	// SecretName The name of Secret to use for connecting the test endpoint
	SecretName *string `json:"secretName,omitempty"`

	// ServiceId Unique identifier of service to test
	ServiceId string `json:"serviceId"`

	// TestEndpoint Endpoint to test for this service
	TestEndpoint string `json:"testEndpoint"`

	// Timeout The maximum time (in milliseconds) to wait for this test ends
	Timeout int `json:"timeout"`
}

// TestResult Represents the result of a Service or API test run by Microcks. Tests are related to a service and made of multiple test cases corresponding to each operations / actions composing service. Tests are run against a specific endpoint named testedEndpoint. It holds global markers telling if test still ran, is a success, how many times is has taken and so on ...
type TestResult struct {
	// AuthorizedClient OAuth2 authorized client that performed a test
	AuthorizedClient *OAuth2AuthorizedClient `json:"authorizedClient,omitempty"`

	// ElapsedTime Elapsed time in milliseconds since test beginning
	ElapsedTime *float32 `json:"elapsedTime,omitempty"`

	// Id Unique identifier of TestResult
	Id string `json:"id"`

	// InProgress Flag telling is test is still in progress
	InProgress bool `json:"inProgress"`

	// OperationHeaders Specification of additional headers for a Service/API operations. Keys are operation name or "globals" (if header applies to all), values are Header objects DTO.
	OperationHeaders *OperationHeaders `json:"operationHeaders,omitempty"`

	// RunnerType Type of test strategy (different strategies are implemented by different runners)
	RunnerType TestRunnerType `json:"runnerType"`

	// SecretRef Lightweight reference for an existing Secret
	SecretRef *SecretRef `json:"secretRef,omitempty"`

	// ServiceId Unique identifier of service tested
	ServiceId string `json:"serviceId"`

	// Success Flag telling if test is a success
	Success bool `json:"success"`

	// TestCaseResults TestCase results associated to this test
	TestCaseResults *[]TestCaseResult `json:"testCaseResults,omitempty"`

	// TestDate Timestamp of creation date of this service
	TestDate int64 `json:"testDate"`

	// TestNumber Incremental number for tracking number of tests of a service
	TestNumber float32 `json:"testNumber"`

	// TestedEndpoint Endpoint used during test
	TestedEndpoint string `json:"testedEndpoint"`

	// Timeout The maximum time (in milliseconds) to wait for this test ends
	Timeout *int `json:"timeout,omitempty"`

	// Version Revision number of this test
	Version float32 `json:"version"`
}

// TestResultSummary Represents the summary result of a Service or API test run by Microcks.
type TestResultSummary struct {
	// Id Unique identifier of TestResult
	Id string `json:"id"`

	// ServiceId Unique identifier of service tested
	ServiceId string `json:"serviceId"`

	// Success Flag telling if test is a success
	Success bool `json:"success"`

	// TestDate Timestamp of creation date of this service
	TestDate int64 `json:"testDate"`
}

// TestRunnerType Type of test strategy (different strategies are implemented by different runners)
type TestRunnerType string

// TestStepResult TestStepResult is an entity embedded within TestCaseResult. They are created for each request associated with an operation / action of a microservice.
type TestStepResult struct {
	// ElapsedTime Elapsed time in milliseconds since the test step beginning
	ElapsedTime *float32 `json:"elapsedTime,omitempty"`

	// EventMessageName Name of event this test step is bound to
	EventMessageName *string `json:"eventMessageName,omitempty"`

	// Message Error message that may be associated to this test step
	Message *string `json:"message,omitempty"`

	// RequestName Name of request this test step is bound to
	RequestName *string `json:"requestName,omitempty"`

	// Success Flag telling if test case is a success
	Success bool `json:"success"`
}

// Trend Evolution trend qualifier
type Trend string

// UnidirectionalEvent defines model for UnidirectionalEvent.
type UnidirectionalEvent struct {
	// EventMessage A simple event message published or received in an asynchronous exchange
	EventMessage EventMessage `json:"eventMessage"`

	// Type Discriminant type for identifying kind of exchange
	Type UnidirectionalEventType `json:"type"`
}

// UnidirectionalEventType Discriminant type for identifying kind of exchange
type UnidirectionalEventType string

// WeightedMetricValue Value of a metric with an associated weight
type WeightedMetricValue struct {
	// Name Metric name or serie name
	Name string `json:"name"`

	// Value The value of this metric
	Value int `json:"value"`

	// Weight Weight of this metric value (typically a percentage)
	Weight int `json:"weight"`
}

// ServiceResponse defines model for ServiceResponse.
type ServiceResponse struct {
	union json.RawMessage
}

// UploadArtifactParams defines parameters for UploadArtifact.
type UploadArtifactParams struct {
	// MainArtifact Flag telling if this should be considered as primary or secondary artifact. Default to 'true'
	MainArtifact bool `form:"mainArtifact" json:"mainArtifact"`
}

// ExportSnapshotParams defines parameters for ExportSnapshot.
type ExportSnapshotParams struct {
	// ServiceIds List of service identifiers to export
	ServiceIds []string `form:"serviceIds" json:"serviceIds"`
}

// GetImportJobsParams defines parameters for GetImportJobs.
type GetImportJobsParams struct {
	// Page Page of ImportJobs to retrieve (starts at and defaults to 0)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Size Size of a page. Maximum number of ImportJobs to include in a response (defaults to 20)
	Size *int `form:"size,omitempty" json:"size,omitempty"`

	// Name Name like criterion for query
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// GetAggregatedInvocationsStatsParams defines parameters for GetAggregatedInvocationsStats.
type GetAggregatedInvocationsStatsParams struct {
	// Day The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.
	Day *string `form:"day,omitempty" json:"day,omitempty"`
}

// GetLatestAggregatedInvocationsStatsParams defines parameters for GetLatestAggregatedInvocationsStats.
type GetLatestAggregatedInvocationsStatsParams struct {
	// Limit Number of days to get back in time. Default is 20.
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTopIvnocationsStatsByDayParams defines parameters for GetTopIvnocationsStatsByDay.
type GetTopIvnocationsStatsByDayParams struct {
	// Day The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.
	Day *string `form:"day,omitempty" json:"day,omitempty"`

	// Limit The number of top invoked mocks to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetInvocationStatsByServiceParams defines parameters for GetInvocationStatsByService.
type GetInvocationStatsByServiceParams struct {
	// Day The day to get statistics for (formatted with yyyyMMdd pattern). Default to today if not provided.
	Day *string `form:"day,omitempty" json:"day,omitempty"`
}

// GetLatestTestResultsParams defines parameters for GetLatestTestResults.
type GetLatestTestResultsParams struct {
	// Limit Number of days to consider for test results to return. Default is 7 (one week)
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSecretsParams defines parameters for GetSecrets.
type GetSecretsParams struct {
	// Page Page of Secrets to retrieve (starts at and defaults to 0)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Size Size of a page. Maximum number of Secrets to include in a response (defaults to 20)
	Size *int `form:"size,omitempty" json:"size,omitempty"`
}

// SearchSecretsParams defines parameters for SearchSecrets.
type SearchSecretsParams struct {
	// Name Search using this name-like criterion
	Name string `form:"name" json:"name"`
}

// GetServicesParams defines parameters for GetServices.
type GetServicesParams struct {
	// Page Page of Services to retrieve (starts at and defaults to 0)
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Size Size of a page. Maximum number of Services to include in a response (defaults to 20)
	Size *int `form:"size,omitempty" json:"size,omitempty"`
}

// SearchServicesParams defines parameters for SearchServices.
type SearchServicesParams struct {
	// QueryMap Map of criterion. Key can be simply 'name' with value as the searched string. You can also search by label using keys like 'labels.x' where 'x' is the label and value the label value
	QueryMap map[string]string `form:"queryMap" json:"queryMap"`
}

// GetServiceParams defines parameters for GetService.
type GetServiceParams struct {
	// Messages Whether to include details on services messages into result. Default is false
	Messages *bool `form:"messages,omitempty" json:"messages,omitempty"`
}

// OverrideServiceOperationParams defines parameters for OverrideServiceOperation.
type OverrideServiceOperationParams struct {
	// OperationName Name of operation to update
	OperationName string `form:"operationName" json:"operationName"`
}

// DownloadArtifactFormdataRequestBody defines body for DownloadArtifact for application/x-www-form-urlencoded ContentType.
type DownloadArtifactFormdataRequestBody = ArtifactDownload

// UploadArtifactMultipartRequestBody defines body for UploadArtifact for multipart/form-data ContentType.
type UploadArtifactMultipartRequestBody = ArtifactUpload

// ImportSnapshotMultipartRequestBody defines body for ImportSnapshot for multipart/form-data ContentType.
type ImportSnapshotMultipartRequestBody = SnapshotUpload

// CreateImportJobJSONRequestBody defines body for CreateImportJob for application/json ContentType.
type CreateImportJobJSONRequestBody = ImportJob

// UpdateImportJobJSONRequestBody defines body for UpdateImportJob for application/json ContentType.
type UpdateImportJobJSONRequestBody = ImportJob

// CreateSecretJSONRequestBody defines body for CreateSecret for application/json ContentType.
type CreateSecretJSONRequestBody = Secret

// UpdateSecretJSONRequestBody defines body for UpdateSecret for application/json ContentType.
type UpdateSecretJSONRequestBody = Secret

// UpdateServiceMetadataJSONRequestBody defines body for UpdateServiceMetadata for application/json ContentType.
type UpdateServiceMetadataJSONRequestBody = Metadata

// OverrideServiceOperationJSONRequestBody defines body for OverrideServiceOperation for application/json ContentType.
type OverrideServiceOperationJSONRequestBody = OperationOverrideDTO

// CreateTestJSONRequestBody defines body for CreateTest for application/json ContentType.
type CreateTestJSONRequestBody = TestRequest

// ReportTestCaseResultJSONRequestBody defines body for ReportTestCaseResult for application/json ContentType.
type ReportTestCaseResultJSONRequestBody = TestCaseReturnDTO

// AsRequestResponsePair returns the union data inside the Exchange as a RequestResponsePair
func (t Exchange) AsRequestResponsePair() (RequestResponsePair, error) {
	var body RequestResponsePair
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestResponsePair overwrites any union data inside the Exchange as the provided RequestResponsePair
func (t *Exchange) FromRequestResponsePair(v RequestResponsePair) error {
	v.Type = "reqRespPair"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestResponsePair performs a merge with any union data inside the Exchange, using the provided RequestResponsePair
func (t *Exchange) MergeRequestResponsePair(v RequestResponsePair) error {
	v.Type = "reqRespPair"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUnidirectionalEvent returns the union data inside the Exchange as a UnidirectionalEvent
func (t Exchange) AsUnidirectionalEvent() (UnidirectionalEvent, error) {
	var body UnidirectionalEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUnidirectionalEvent overwrites any union data inside the Exchange as the provided UnidirectionalEvent
func (t *Exchange) FromUnidirectionalEvent(v UnidirectionalEvent) error {
	v.Type = "unidirEvent"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUnidirectionalEvent performs a merge with any union data inside the Exchange, using the provided UnidirectionalEvent
func (t *Exchange) MergeUnidirectionalEvent(v UnidirectionalEvent) error {
	v.Type = "unidirEvent"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Exchange) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Exchange) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "reqRespPair":
		return t.AsRequestResponsePair()
	case "unidirEvent":
		return t.AsUnidirectionalEvent()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Exchange) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Exchange) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsService returns the union data inside the ServiceResponse as a Service
func (t ServiceResponse) AsService() (Service, error) {
	var body Service
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromService overwrites any union data inside the ServiceResponse as the provided Service
func (t *ServiceResponse) FromService(v Service) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeService performs a merge with any union data inside the ServiceResponse, using the provided Service
func (t *ServiceResponse) MergeService(v Service) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServiceView returns the union data inside the ServiceResponse as a ServiceView
func (t ServiceResponse) AsServiceView() (ServiceView, error) {
	var body ServiceView
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServiceView overwrites any union data inside the ServiceResponse as the provided ServiceView
func (t *ServiceResponse) FromServiceView(v ServiceView) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServiceView performs a merge with any union data inside the ServiceResponse, using the provided ServiceView
func (t *ServiceResponse) MergeServiceView(v ServiceView) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ServiceResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ServiceResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DownloadArtifactWithBody request with any body
	DownloadArtifactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DownloadArtifactWithFormdataBody(ctx context.Context, body DownloadArtifactFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadArtifactWithBody request with any body
	UploadArtifactWithBody(ctx context.Context, params *UploadArtifactParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportSnapshot request
	ExportSnapshot(ctx context.Context, params *ExportSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeaturesConfig request
	GetFeaturesConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportSnapshotWithBody request with any body
	ImportSnapshotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImportJobs request
	GetImportJobs(ctx context.Context, params *GetImportJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateImportJobWithBody request with any body
	CreateImportJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateImportJob(ctx context.Context, body CreateImportJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImportJobCounter request
	GetImportJobCounter(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteImportJob request
	DeleteImportJob(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetImportJob request
	GetImportJob(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateImportJobWithBody request with any body
	UpdateImportJobWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateImportJob(ctx context.Context, id string, body UpdateImportJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivateImportJob request
	ActivateImportJob(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartImportJob request
	StartImportJob(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StopImportJob request
	StopImportJob(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeycloakConfig request
	GetKeycloakConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConformanceMetricsAggregation request
	GetConformanceMetricsAggregation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceTestConformanceMetric request
	GetServiceTestConformanceMetric(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAggregatedInvocationsStats request
	GetAggregatedInvocationsStats(ctx context.Context, params *GetAggregatedInvocationsStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestAggregatedInvocationsStats request
	GetLatestAggregatedInvocationsStats(ctx context.Context, params *GetLatestAggregatedInvocationsStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopIvnocationsStatsByDay request
	GetTopIvnocationsStatsByDay(ctx context.Context, params *GetTopIvnocationsStatsByDayParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvocationStatsByService request
	GetInvocationStatsByService(ctx context.Context, serviceName string, serviceVersion string, params *GetInvocationStatsByServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatestTestResults request
	GetLatestTestResults(ctx context.Context, params *GetLatestTestResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResourcesByService request
	GetResourcesByService(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecrets request
	GetSecrets(ctx context.Context, params *GetSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSecretWithBody request with any body
	CreateSecretWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSecret(ctx context.Context, body CreateSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecretsCounter request
	GetSecretsCounter(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchSecrets request
	SearchSecrets(ctx context.Context, params *SearchSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecret request
	DeleteSecret(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecret request
	GetSecret(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSecretWithBody request with any body
	UpdateSecretWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSecret(ctx context.Context, id string, body UpdateSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServices request
	GetServices(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesCounter request
	GetServicesCounter(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesLabels request
	GetServicesLabels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchServices request
	SearchServices(ctx context.Context, params *SearchServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteService request
	DeleteService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetService request
	GetService(ctx context.Context, id string, params *GetServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceMetadataWithBody request with any body
	UpdateServiceMetadataWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceMetadata(ctx context.Context, id string, body UpdateServiceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OverrideServiceOperationWithBody request with any body
	OverrideServiceOperationWithBody(ctx context.Context, id string, params *OverrideServiceOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OverrideServiceOperation(ctx context.Context, id string, params *OverrideServiceOperationParams, body OverrideServiceOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTestWithBody request with any body
	CreateTestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTest(ctx context.Context, body CreateTestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTestResultsByService request
	GetTestResultsByService(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTestResultsByServiceCounter request
	GetTestResultsByServiceCounter(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTestResult request
	GetTestResult(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventsByTestCase request
	GetEventsByTestCase(ctx context.Context, id string, testCaseId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMessagesByTestCase request
	GetMessagesByTestCase(ctx context.Context, id string, testCaseId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReportTestCaseResultWithBody request with any body
	ReportTestCaseResultWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReportTestCaseResult(ctx context.Context, id string, body ReportTestCaseResultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DownloadArtifactWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadArtifactRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadArtifactWithFormdataBody(ctx context.Context, body DownloadArtifactFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadArtifactRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadArtifactWithBody(ctx context.Context, params *UploadArtifactParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadArtifactRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportSnapshot(ctx context.Context, params *ExportSnapshotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSnapshotRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeaturesConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeaturesConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportSnapshotWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportSnapshotRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImportJobs(ctx context.Context, params *GetImportJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImportJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImportJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImportJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateImportJob(ctx context.Context, body CreateImportJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateImportJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImportJobCounter(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImportJobCounterRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteImportJob(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteImportJobRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetImportJob(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetImportJobRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImportJobWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImportJobRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateImportJob(ctx context.Context, id string, body UpdateImportJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateImportJobRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivateImportJob(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivateImportJobRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartImportJob(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartImportJobRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StopImportJob(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStopImportJobRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeycloakConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeycloakConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConformanceMetricsAggregation(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConformanceMetricsAggregationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceTestConformanceMetric(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceTestConformanceMetricRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAggregatedInvocationsStats(ctx context.Context, params *GetAggregatedInvocationsStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAggregatedInvocationsStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestAggregatedInvocationsStats(ctx context.Context, params *GetLatestAggregatedInvocationsStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestAggregatedInvocationsStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopIvnocationsStatsByDay(ctx context.Context, params *GetTopIvnocationsStatsByDayParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopIvnocationsStatsByDayRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvocationStatsByService(ctx context.Context, serviceName string, serviceVersion string, params *GetInvocationStatsByServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvocationStatsByServiceRequest(c.Server, serviceName, serviceVersion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatestTestResults(ctx context.Context, params *GetLatestTestResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatestTestResultsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResourcesByService(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcesByServiceRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecrets(ctx context.Context, params *GetSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecretsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecretWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecretRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSecret(ctx context.Context, body CreateSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSecretRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecretsCounter(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecretsCounterRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchSecrets(ctx context.Context, params *SearchSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchSecretsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecret(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecretRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecret(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecretRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSecretWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSecretRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSecret(ctx context.Context, id string, body UpdateSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSecretRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServices(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesCounter(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesCounterRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesLabels(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesLabelsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchServices(ctx context.Context, params *SearchServicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchServicesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteService(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetService(ctx context.Context, id string, params *GetServiceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceMetadataWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceMetadataRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceMetadata(ctx context.Context, id string, body UpdateServiceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceMetadataRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OverrideServiceOperationWithBody(ctx context.Context, id string, params *OverrideServiceOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOverrideServiceOperationRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OverrideServiceOperation(ctx context.Context, id string, params *OverrideServiceOperationParams, body OverrideServiceOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOverrideServiceOperationRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTest(ctx context.Context, body CreateTestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTestResultsByService(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTestResultsByServiceRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTestResultsByServiceCounter(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTestResultsByServiceCounterRequest(c.Server, serviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTestResult(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTestResultRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventsByTestCase(ctx context.Context, id string, testCaseId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsByTestCaseRequest(c.Server, id, testCaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMessagesByTestCase(ctx context.Context, id string, testCaseId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMessagesByTestCaseRequest(c.Server, id, testCaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportTestCaseResultWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportTestCaseResultRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReportTestCaseResult(ctx context.Context, id string, body ReportTestCaseResultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReportTestCaseResultRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDownloadArtifactRequestWithFormdataBody calls the generic DownloadArtifact builder with application/x-www-form-urlencoded body
func NewDownloadArtifactRequestWithFormdataBody(server string, body DownloadArtifactFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewDownloadArtifactRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewDownloadArtifactRequestWithBody generates requests for DownloadArtifact with any type of body
func NewDownloadArtifactRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifact/download")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUploadArtifactRequestWithBody generates requests for UploadArtifact with any type of body
func NewUploadArtifactRequestWithBody(server string, params *UploadArtifactParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/artifact/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mainArtifact", runtime.ParamLocationQuery, params.MainArtifact); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExportSnapshotRequest generates requests for ExportSnapshot
func NewExportSnapshotRequest(server string, params *ExportSnapshotParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "serviceIds", runtime.ParamLocationQuery, params.ServiceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFeaturesConfigRequest generates requests for GetFeaturesConfig
func NewGetFeaturesConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/features/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewImportSnapshotRequestWithBody generates requests for ImportSnapshot with any type of body
func NewImportSnapshotRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/import")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetImportJobsRequest generates requests for GetImportJobs
func NewGetImportJobsRequest(server string, params *GetImportJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateImportJobRequest calls the generic CreateImportJob builder with application/json body
func NewCreateImportJobRequest(server string, body CreateImportJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateImportJobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateImportJobRequestWithBody generates requests for CreateImportJob with any type of body
func NewCreateImportJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetImportJobCounterRequest generates requests for GetImportJobCounter
func NewGetImportJobCounterRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteImportJobRequest generates requests for DeleteImportJob
func NewDeleteImportJobRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetImportJobRequest generates requests for GetImportJob
func NewGetImportJobRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateImportJobRequest calls the generic UpdateImportJob builder with application/json body
func NewUpdateImportJobRequest(server string, id string, body UpdateImportJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateImportJobRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateImportJobRequestWithBody generates requests for UpdateImportJob with any type of body
func NewUpdateImportJobRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActivateImportJobRequest generates requests for ActivateImportJob
func NewActivateImportJobRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/activate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartImportJobRequest generates requests for StartImportJob
func NewStartImportJobRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStopImportJobRequest generates requests for StopImportJob
func NewStopImportJobRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobs/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeycloakConfigRequest generates requests for GetKeycloakConfig
func NewGetKeycloakConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keycloak/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConformanceMetricsAggregationRequest generates requests for GetConformanceMetricsAggregation
func NewGetConformanceMetricsAggregationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metrics/conformance/aggregate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceTestConformanceMetricRequest generates requests for GetServiceTestConformanceMetric
func NewGetServiceTestConformanceMetricRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metrics/conformance/service/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAggregatedInvocationsStatsRequest generates requests for GetAggregatedInvocationsStats
func NewGetAggregatedInvocationsStatsRequest(server string, params *GetAggregatedInvocationsStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metrics/invocations/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Day != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "day", runtime.ParamLocationQuery, *params.Day); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLatestAggregatedInvocationsStatsRequest generates requests for GetLatestAggregatedInvocationsStats
func NewGetLatestAggregatedInvocationsStatsRequest(server string, params *GetLatestAggregatedInvocationsStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metrics/invocations/global/latest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopIvnocationsStatsByDayRequest generates requests for GetTopIvnocationsStatsByDay
func NewGetTopIvnocationsStatsByDayRequest(server string, params *GetTopIvnocationsStatsByDayParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metrics/invocations/top")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Day != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "day", runtime.ParamLocationQuery, *params.Day); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvocationStatsByServiceRequest generates requests for GetInvocationStatsByService
func NewGetInvocationStatsByServiceRequest(server string, serviceName string, serviceVersion string, params *GetInvocationStatsByServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceName", runtime.ParamLocationPath, serviceName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceVersion", runtime.ParamLocationPath, serviceVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metrics/invocations/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Day != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "day", runtime.ParamLocationQuery, *params.Day); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLatestTestResultsRequest generates requests for GetLatestTestResults
func NewGetLatestTestResultsRequest(server string, params *GetLatestTestResultsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/metrics/tests/latest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcesByServiceRequest generates requests for GetResourcesByService
func NewGetResourcesByServiceRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/service/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecretsRequest generates requests for GetSecrets
func NewGetSecretsRequest(server string, params *GetSecretsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSecretRequest calls the generic CreateSecret builder with application/json body
func NewCreateSecretRequest(server string, body CreateSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSecretRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSecretRequestWithBody generates requests for CreateSecret with any type of body
func NewCreateSecretRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSecretsCounterRequest generates requests for GetSecretsCounter
func NewGetSecretsCounterRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secrets/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchSecretsRequest generates requests for SearchSecrets
func NewSearchSecretsRequest(server string, params *SearchSecretsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secrets/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSecretRequest generates requests for DeleteSecret
func NewDeleteSecretRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secrets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecretRequest generates requests for GetSecret
func NewGetSecretRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secrets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSecretRequest calls the generic UpdateSecret builder with application/json body
func NewUpdateSecretRequest(server string, id string, body UpdateSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSecretRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateSecretRequestWithBody generates requests for UpdateSecret with any type of body
func NewUpdateSecretRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secrets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServicesRequest generates requests for GetServices
func NewGetServicesRequest(server string, params *GetServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Size != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "size", runtime.ParamLocationQuery, *params.Size); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesCounterRequest generates requests for GetServicesCounter
func NewGetServicesCounterRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/count")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesLabelsRequest generates requests for GetServicesLabels
func NewGetServicesLabelsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/labels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchServicesRequest generates requests for SearchServices
func NewSearchServicesRequest(server string, params *SearchServicesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "queryMap", runtime.ParamLocationQuery, params.QueryMap); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteServiceRequest generates requests for DeleteService
func NewDeleteServiceRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceRequest generates requests for GetService
func NewGetServiceRequest(server string, id string, params *GetServiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Messages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messages", runtime.ParamLocationQuery, *params.Messages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateServiceMetadataRequest calls the generic UpdateServiceMetadata builder with application/json body
func NewUpdateServiceMetadataRequest(server string, id string, body UpdateServiceMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceMetadataRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateServiceMetadataRequestWithBody generates requests for UpdateServiceMetadata with any type of body
func NewUpdateServiceMetadataRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOverrideServiceOperationRequest calls the generic OverrideServiceOperation builder with application/json body
func NewOverrideServiceOperationRequest(server string, id string, params *OverrideServiceOperationParams, body OverrideServiceOperationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOverrideServiceOperationRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewOverrideServiceOperationRequestWithBody generates requests for OverrideServiceOperation with any type of body
func NewOverrideServiceOperationRequestWithBody(server string, id string, params *OverrideServiceOperationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/%s/operation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operationName", runtime.ParamLocationQuery, params.OperationName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTestRequest calls the generic CreateTest builder with application/json body
func NewCreateTestRequest(server string, body CreateTestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTestRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTestRequestWithBody generates requests for CreateTest with any type of body
func NewCreateTestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTestResultsByServiceRequest generates requests for GetTestResultsByService
func NewGetTestResultsByServiceRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tests/service/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTestResultsByServiceCounterRequest generates requests for GetTestResultsByServiceCounter
func NewGetTestResultsByServiceCounterRequest(server string, serviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceId", runtime.ParamLocationPath, serviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tests/service/%s/count", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTestResultRequest generates requests for GetTestResult
func NewGetTestResultRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventsByTestCaseRequest generates requests for GetEventsByTestCase
func NewGetEventsByTestCaseRequest(server string, id string, testCaseId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testCaseId", runtime.ParamLocationPath, testCaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tests/%s/events/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMessagesByTestCaseRequest generates requests for GetMessagesByTestCase
func NewGetMessagesByTestCaseRequest(server string, id string, testCaseId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "testCaseId", runtime.ParamLocationPath, testCaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tests/%s/messages/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReportTestCaseResultRequest calls the generic ReportTestCaseResult builder with application/json body
func NewReportTestCaseResultRequest(server string, id string, body ReportTestCaseResultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReportTestCaseResultRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReportTestCaseResultRequestWithBody generates requests for ReportTestCaseResult with any type of body
func NewReportTestCaseResultRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tests/%s/testCaseResult", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DownloadArtifactWithBodyWithResponse request with any body
	DownloadArtifactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadArtifactResponse, error)

	DownloadArtifactWithFormdataBodyWithResponse(ctx context.Context, body DownloadArtifactFormdataRequestBody, reqEditors ...RequestEditorFn) (*DownloadArtifactResponse, error)

	// UploadArtifactWithBodyWithResponse request with any body
	UploadArtifactWithBodyWithResponse(ctx context.Context, params *UploadArtifactParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadArtifactResponse, error)

	// ExportSnapshotWithResponse request
	ExportSnapshotWithResponse(ctx context.Context, params *ExportSnapshotParams, reqEditors ...RequestEditorFn) (*ExportSnapshotResponse, error)

	// GetFeaturesConfigWithResponse request
	GetFeaturesConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFeaturesConfigResponse, error)

	// ImportSnapshotWithBodyWithResponse request with any body
	ImportSnapshotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportSnapshotResponse, error)

	// GetImportJobsWithResponse request
	GetImportJobsWithResponse(ctx context.Context, params *GetImportJobsParams, reqEditors ...RequestEditorFn) (*GetImportJobsResponse, error)

	// CreateImportJobWithBodyWithResponse request with any body
	CreateImportJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImportJobResponse, error)

	CreateImportJobWithResponse(ctx context.Context, body CreateImportJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImportJobResponse, error)

	// GetImportJobCounterWithResponse request
	GetImportJobCounterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetImportJobCounterResponse, error)

	// DeleteImportJobWithResponse request
	DeleteImportJobWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteImportJobResponse, error)

	// GetImportJobWithResponse request
	GetImportJobWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetImportJobResponse, error)

	// UpdateImportJobWithBodyWithResponse request with any body
	UpdateImportJobWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImportJobResponse, error)

	UpdateImportJobWithResponse(ctx context.Context, id string, body UpdateImportJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImportJobResponse, error)

	// ActivateImportJobWithResponse request
	ActivateImportJobWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ActivateImportJobResponse, error)

	// StartImportJobWithResponse request
	StartImportJobWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*StartImportJobResponse, error)

	// StopImportJobWithResponse request
	StopImportJobWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*StopImportJobResponse, error)

	// GetKeycloakConfigWithResponse request
	GetKeycloakConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeycloakConfigResponse, error)

	// GetConformanceMetricsAggregationWithResponse request
	GetConformanceMetricsAggregationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConformanceMetricsAggregationResponse, error)

	// GetServiceTestConformanceMetricWithResponse request
	GetServiceTestConformanceMetricWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceTestConformanceMetricResponse, error)

	// GetAggregatedInvocationsStatsWithResponse request
	GetAggregatedInvocationsStatsWithResponse(ctx context.Context, params *GetAggregatedInvocationsStatsParams, reqEditors ...RequestEditorFn) (*GetAggregatedInvocationsStatsResponse, error)

	// GetLatestAggregatedInvocationsStatsWithResponse request
	GetLatestAggregatedInvocationsStatsWithResponse(ctx context.Context, params *GetLatestAggregatedInvocationsStatsParams, reqEditors ...RequestEditorFn) (*GetLatestAggregatedInvocationsStatsResponse, error)

	// GetTopIvnocationsStatsByDayWithResponse request
	GetTopIvnocationsStatsByDayWithResponse(ctx context.Context, params *GetTopIvnocationsStatsByDayParams, reqEditors ...RequestEditorFn) (*GetTopIvnocationsStatsByDayResponse, error)

	// GetInvocationStatsByServiceWithResponse request
	GetInvocationStatsByServiceWithResponse(ctx context.Context, serviceName string, serviceVersion string, params *GetInvocationStatsByServiceParams, reqEditors ...RequestEditorFn) (*GetInvocationStatsByServiceResponse, error)

	// GetLatestTestResultsWithResponse request
	GetLatestTestResultsWithResponse(ctx context.Context, params *GetLatestTestResultsParams, reqEditors ...RequestEditorFn) (*GetLatestTestResultsResponse, error)

	// GetResourcesByServiceWithResponse request
	GetResourcesByServiceWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetResourcesByServiceResponse, error)

	// GetResourceWithResponse request
	GetResourceWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// GetSecretsWithResponse request
	GetSecretsWithResponse(ctx context.Context, params *GetSecretsParams, reqEditors ...RequestEditorFn) (*GetSecretsResponse, error)

	// CreateSecretWithBodyWithResponse request with any body
	CreateSecretWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecretResponse, error)

	CreateSecretWithResponse(ctx context.Context, body CreateSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecretResponse, error)

	// GetSecretsCounterWithResponse request
	GetSecretsCounterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSecretsCounterResponse, error)

	// SearchSecretsWithResponse request
	SearchSecretsWithResponse(ctx context.Context, params *SearchSecretsParams, reqEditors ...RequestEditorFn) (*SearchSecretsResponse, error)

	// DeleteSecretWithResponse request
	DeleteSecretWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSecretResponse, error)

	// GetSecretWithResponse request
	GetSecretWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSecretResponse, error)

	// UpdateSecretWithBodyWithResponse request with any body
	UpdateSecretWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSecretResponse, error)

	UpdateSecretWithResponse(ctx context.Context, id string, body UpdateSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSecretResponse, error)

	// GetServicesWithResponse request
	GetServicesWithResponse(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*GetServicesResponse, error)

	// GetServicesCounterWithResponse request
	GetServicesCounterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesCounterResponse, error)

	// GetServicesLabelsWithResponse request
	GetServicesLabelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesLabelsResponse, error)

	// SearchServicesWithResponse request
	SearchServicesWithResponse(ctx context.Context, params *SearchServicesParams, reqEditors ...RequestEditorFn) (*SearchServicesResponse, error)

	// DeleteServiceWithResponse request
	DeleteServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteServiceResponse, error)

	// GetServiceWithResponse request
	GetServiceWithResponse(ctx context.Context, id string, params *GetServiceParams, reqEditors ...RequestEditorFn) (*GetServiceResponse, error)

	// UpdateServiceMetadataWithBodyWithResponse request with any body
	UpdateServiceMetadataWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceMetadataResponse, error)

	UpdateServiceMetadataWithResponse(ctx context.Context, id string, body UpdateServiceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceMetadataResponse, error)

	// OverrideServiceOperationWithBodyWithResponse request with any body
	OverrideServiceOperationWithBodyWithResponse(ctx context.Context, id string, params *OverrideServiceOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OverrideServiceOperationResponse, error)

	OverrideServiceOperationWithResponse(ctx context.Context, id string, params *OverrideServiceOperationParams, body OverrideServiceOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*OverrideServiceOperationResponse, error)

	// CreateTestWithBodyWithResponse request with any body
	CreateTestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTestResponse, error)

	CreateTestWithResponse(ctx context.Context, body CreateTestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTestResponse, error)

	// GetTestResultsByServiceWithResponse request
	GetTestResultsByServiceWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetTestResultsByServiceResponse, error)

	// GetTestResultsByServiceCounterWithResponse request
	GetTestResultsByServiceCounterWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetTestResultsByServiceCounterResponse, error)

	// GetTestResultWithResponse request
	GetTestResultWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTestResultResponse, error)

	// GetEventsByTestCaseWithResponse request
	GetEventsByTestCaseWithResponse(ctx context.Context, id string, testCaseId string, reqEditors ...RequestEditorFn) (*GetEventsByTestCaseResponse, error)

	// GetMessagesByTestCaseWithResponse request
	GetMessagesByTestCaseWithResponse(ctx context.Context, id string, testCaseId string, reqEditors ...RequestEditorFn) (*GetMessagesByTestCaseResponse, error)

	// ReportTestCaseResultWithBodyWithResponse request with any body
	ReportTestCaseResultWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportTestCaseResultResponse, error)

	ReportTestCaseResultWithResponse(ctx context.Context, id string, body ReportTestCaseResultJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportTestCaseResultResponse, error)
}

type DownloadArtifactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DownloadArtifactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadArtifactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadArtifactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UploadArtifactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadArtifactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *openapi_types.File
}

// Status returns HTTPResponse.Status
func (r ExportSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeaturesConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetFeaturesConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeaturesConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportSnapshotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ImportSnapshotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportSnapshotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImportJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ImportJob
}

// Status returns HTTPResponse.Status
func (r GetImportJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImportJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateImportJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ImportJob
}

// Status returns HTTPResponse.Status
func (r CreateImportJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateImportJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImportJobCounterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Counter
}

// Status returns HTTPResponse.Status
func (r GetImportJobCounterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImportJobCounterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteImportJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteImportJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteImportJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetImportJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImportJob
}

// Status returns HTTPResponse.Status
func (r GetImportJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetImportJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateImportJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImportJob
}

// Status returns HTTPResponse.Status
func (r UpdateImportJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateImportJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivateImportJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImportJob
}

// Status returns HTTPResponse.Status
func (r ActivateImportJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivateImportJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartImportJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImportJob
}

// Status returns HTTPResponse.Status
func (r StartImportJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartImportJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StopImportJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImportJob
}

// Status returns HTTPResponse.Status
func (r StopImportJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StopImportJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeycloakConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeycloakConfig
}

// Status returns HTTPResponse.Status
func (r GetKeycloakConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeycloakConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConformanceMetricsAggregationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WeightedMetricValue
}

// Status returns HTTPResponse.Status
func (r GetConformanceMetricsAggregationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConformanceMetricsAggregationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceTestConformanceMetricResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestConformanceMetric
}

// Status returns HTTPResponse.Status
func (r GetServiceTestConformanceMetricResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceTestConformanceMetricResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAggregatedInvocationsStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DailyInvocationStatistic
}

// Status returns HTTPResponse.Status
func (r GetAggregatedInvocationsStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAggregatedInvocationsStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestAggregatedInvocationsStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CounterMap
}

// Status returns HTTPResponse.Status
func (r GetLatestAggregatedInvocationsStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestAggregatedInvocationsStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopIvnocationsStatsByDayResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DailyInvocationStatistic
}

// Status returns HTTPResponse.Status
func (r GetTopIvnocationsStatsByDayResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopIvnocationsStatsByDayResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvocationStatsByServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DailyInvocationStatistic
}

// Status returns HTTPResponse.Status
func (r GetInvocationStatsByServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvocationStatsByServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatestTestResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TestResultSummary
}

// Status returns HTTPResponse.Status
func (r GetLatestTestResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatestTestResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcesByServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Resource
}

// Status returns HTTPResponse.Status
func (r GetResourcesByServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcesByServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resource
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Secret
}

// Status returns HTTPResponse.Status
func (r GetSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Secret
}

// Status returns HTTPResponse.Status
func (r CreateSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecretsCounterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Counter
}

// Status returns HTTPResponse.Status
func (r GetSecretsCounterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecretsCounterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Secret
}

// Status returns HTTPResponse.Status
func (r SearchSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Secret
}

// Status returns HTTPResponse.Status
func (r GetSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Secret
}

// Status returns HTTPResponse.Status
func (r UpdateSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Service
}

// Status returns HTTPResponse.Status
func (r GetServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesCounterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Counter
}

// Status returns HTTPResponse.Status
func (r GetServicesCounterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesCounterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LabelsMap
}

// Status returns HTTPResponse.Status
func (r GetServicesLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchServicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Service
}

// Status returns HTTPResponse.Status
func (r SearchServicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchServicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceResponse
}

// Status returns HTTPResponse.Status
func (r GetServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateServiceMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OverrideServiceOperationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OverrideServiceOperationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OverrideServiceOperationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TestResult
}

// Status returns HTTPResponse.Status
func (r CreateTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTestResultsByServiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TestResult
}

// Status returns HTTPResponse.Status
func (r GetTestResultsByServiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTestResultsByServiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTestResultsByServiceCounterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Counter
}

// Status returns HTTPResponse.Status
func (r GetTestResultsByServiceCounterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTestResultsByServiceCounterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTestResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestResult
}

// Status returns HTTPResponse.Status
func (r GetTestResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTestResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsByTestCaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UnidirectionalEvent
}

// Status returns HTTPResponse.Status
func (r GetEventsByTestCaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsByTestCaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMessagesByTestCaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RequestResponsePair
}

// Status returns HTTPResponse.Status
func (r GetMessagesByTestCaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMessagesByTestCaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReportTestCaseResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TestCaseResult
}

// Status returns HTTPResponse.Status
func (r ReportTestCaseResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReportTestCaseResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DownloadArtifactWithBodyWithResponse request with arbitrary body returning *DownloadArtifactResponse
func (c *ClientWithResponses) DownloadArtifactWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DownloadArtifactResponse, error) {
	rsp, err := c.DownloadArtifactWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadArtifactResponse(rsp)
}

func (c *ClientWithResponses) DownloadArtifactWithFormdataBodyWithResponse(ctx context.Context, body DownloadArtifactFormdataRequestBody, reqEditors ...RequestEditorFn) (*DownloadArtifactResponse, error) {
	rsp, err := c.DownloadArtifactWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadArtifactResponse(rsp)
}

// UploadArtifactWithBodyWithResponse request with arbitrary body returning *UploadArtifactResponse
func (c *ClientWithResponses) UploadArtifactWithBodyWithResponse(ctx context.Context, params *UploadArtifactParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadArtifactResponse, error) {
	rsp, err := c.UploadArtifactWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadArtifactResponse(rsp)
}

// ExportSnapshotWithResponse request returning *ExportSnapshotResponse
func (c *ClientWithResponses) ExportSnapshotWithResponse(ctx context.Context, params *ExportSnapshotParams, reqEditors ...RequestEditorFn) (*ExportSnapshotResponse, error) {
	rsp, err := c.ExportSnapshot(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSnapshotResponse(rsp)
}

// GetFeaturesConfigWithResponse request returning *GetFeaturesConfigResponse
func (c *ClientWithResponses) GetFeaturesConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFeaturesConfigResponse, error) {
	rsp, err := c.GetFeaturesConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeaturesConfigResponse(rsp)
}

// ImportSnapshotWithBodyWithResponse request with arbitrary body returning *ImportSnapshotResponse
func (c *ClientWithResponses) ImportSnapshotWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportSnapshotResponse, error) {
	rsp, err := c.ImportSnapshotWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportSnapshotResponse(rsp)
}

// GetImportJobsWithResponse request returning *GetImportJobsResponse
func (c *ClientWithResponses) GetImportJobsWithResponse(ctx context.Context, params *GetImportJobsParams, reqEditors ...RequestEditorFn) (*GetImportJobsResponse, error) {
	rsp, err := c.GetImportJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImportJobsResponse(rsp)
}

// CreateImportJobWithBodyWithResponse request with arbitrary body returning *CreateImportJobResponse
func (c *ClientWithResponses) CreateImportJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateImportJobResponse, error) {
	rsp, err := c.CreateImportJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImportJobResponse(rsp)
}

func (c *ClientWithResponses) CreateImportJobWithResponse(ctx context.Context, body CreateImportJobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateImportJobResponse, error) {
	rsp, err := c.CreateImportJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateImportJobResponse(rsp)
}

// GetImportJobCounterWithResponse request returning *GetImportJobCounterResponse
func (c *ClientWithResponses) GetImportJobCounterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetImportJobCounterResponse, error) {
	rsp, err := c.GetImportJobCounter(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImportJobCounterResponse(rsp)
}

// DeleteImportJobWithResponse request returning *DeleteImportJobResponse
func (c *ClientWithResponses) DeleteImportJobWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteImportJobResponse, error) {
	rsp, err := c.DeleteImportJob(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteImportJobResponse(rsp)
}

// GetImportJobWithResponse request returning *GetImportJobResponse
func (c *ClientWithResponses) GetImportJobWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetImportJobResponse, error) {
	rsp, err := c.GetImportJob(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetImportJobResponse(rsp)
}

// UpdateImportJobWithBodyWithResponse request with arbitrary body returning *UpdateImportJobResponse
func (c *ClientWithResponses) UpdateImportJobWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateImportJobResponse, error) {
	rsp, err := c.UpdateImportJobWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImportJobResponse(rsp)
}

func (c *ClientWithResponses) UpdateImportJobWithResponse(ctx context.Context, id string, body UpdateImportJobJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateImportJobResponse, error) {
	rsp, err := c.UpdateImportJob(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateImportJobResponse(rsp)
}

// ActivateImportJobWithResponse request returning *ActivateImportJobResponse
func (c *ClientWithResponses) ActivateImportJobWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*ActivateImportJobResponse, error) {
	rsp, err := c.ActivateImportJob(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivateImportJobResponse(rsp)
}

// StartImportJobWithResponse request returning *StartImportJobResponse
func (c *ClientWithResponses) StartImportJobWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*StartImportJobResponse, error) {
	rsp, err := c.StartImportJob(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartImportJobResponse(rsp)
}

// StopImportJobWithResponse request returning *StopImportJobResponse
func (c *ClientWithResponses) StopImportJobWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*StopImportJobResponse, error) {
	rsp, err := c.StopImportJob(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStopImportJobResponse(rsp)
}

// GetKeycloakConfigWithResponse request returning *GetKeycloakConfigResponse
func (c *ClientWithResponses) GetKeycloakConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeycloakConfigResponse, error) {
	rsp, err := c.GetKeycloakConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeycloakConfigResponse(rsp)
}

// GetConformanceMetricsAggregationWithResponse request returning *GetConformanceMetricsAggregationResponse
func (c *ClientWithResponses) GetConformanceMetricsAggregationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConformanceMetricsAggregationResponse, error) {
	rsp, err := c.GetConformanceMetricsAggregation(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConformanceMetricsAggregationResponse(rsp)
}

// GetServiceTestConformanceMetricWithResponse request returning *GetServiceTestConformanceMetricResponse
func (c *ClientWithResponses) GetServiceTestConformanceMetricWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetServiceTestConformanceMetricResponse, error) {
	rsp, err := c.GetServiceTestConformanceMetric(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceTestConformanceMetricResponse(rsp)
}

// GetAggregatedInvocationsStatsWithResponse request returning *GetAggregatedInvocationsStatsResponse
func (c *ClientWithResponses) GetAggregatedInvocationsStatsWithResponse(ctx context.Context, params *GetAggregatedInvocationsStatsParams, reqEditors ...RequestEditorFn) (*GetAggregatedInvocationsStatsResponse, error) {
	rsp, err := c.GetAggregatedInvocationsStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAggregatedInvocationsStatsResponse(rsp)
}

// GetLatestAggregatedInvocationsStatsWithResponse request returning *GetLatestAggregatedInvocationsStatsResponse
func (c *ClientWithResponses) GetLatestAggregatedInvocationsStatsWithResponse(ctx context.Context, params *GetLatestAggregatedInvocationsStatsParams, reqEditors ...RequestEditorFn) (*GetLatestAggregatedInvocationsStatsResponse, error) {
	rsp, err := c.GetLatestAggregatedInvocationsStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestAggregatedInvocationsStatsResponse(rsp)
}

// GetTopIvnocationsStatsByDayWithResponse request returning *GetTopIvnocationsStatsByDayResponse
func (c *ClientWithResponses) GetTopIvnocationsStatsByDayWithResponse(ctx context.Context, params *GetTopIvnocationsStatsByDayParams, reqEditors ...RequestEditorFn) (*GetTopIvnocationsStatsByDayResponse, error) {
	rsp, err := c.GetTopIvnocationsStatsByDay(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopIvnocationsStatsByDayResponse(rsp)
}

// GetInvocationStatsByServiceWithResponse request returning *GetInvocationStatsByServiceResponse
func (c *ClientWithResponses) GetInvocationStatsByServiceWithResponse(ctx context.Context, serviceName string, serviceVersion string, params *GetInvocationStatsByServiceParams, reqEditors ...RequestEditorFn) (*GetInvocationStatsByServiceResponse, error) {
	rsp, err := c.GetInvocationStatsByService(ctx, serviceName, serviceVersion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvocationStatsByServiceResponse(rsp)
}

// GetLatestTestResultsWithResponse request returning *GetLatestTestResultsResponse
func (c *ClientWithResponses) GetLatestTestResultsWithResponse(ctx context.Context, params *GetLatestTestResultsParams, reqEditors ...RequestEditorFn) (*GetLatestTestResultsResponse, error) {
	rsp, err := c.GetLatestTestResults(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatestTestResultsResponse(rsp)
}

// GetResourcesByServiceWithResponse request returning *GetResourcesByServiceResponse
func (c *ClientWithResponses) GetResourcesByServiceWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetResourcesByServiceResponse, error) {
	rsp, err := c.GetResourcesByService(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcesByServiceResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// GetSecretsWithResponse request returning *GetSecretsResponse
func (c *ClientWithResponses) GetSecretsWithResponse(ctx context.Context, params *GetSecretsParams, reqEditors ...RequestEditorFn) (*GetSecretsResponse, error) {
	rsp, err := c.GetSecrets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecretsResponse(rsp)
}

// CreateSecretWithBodyWithResponse request with arbitrary body returning *CreateSecretResponse
func (c *ClientWithResponses) CreateSecretWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSecretResponse, error) {
	rsp, err := c.CreateSecretWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecretResponse(rsp)
}

func (c *ClientWithResponses) CreateSecretWithResponse(ctx context.Context, body CreateSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSecretResponse, error) {
	rsp, err := c.CreateSecret(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSecretResponse(rsp)
}

// GetSecretsCounterWithResponse request returning *GetSecretsCounterResponse
func (c *ClientWithResponses) GetSecretsCounterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSecretsCounterResponse, error) {
	rsp, err := c.GetSecretsCounter(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecretsCounterResponse(rsp)
}

// SearchSecretsWithResponse request returning *SearchSecretsResponse
func (c *ClientWithResponses) SearchSecretsWithResponse(ctx context.Context, params *SearchSecretsParams, reqEditors ...RequestEditorFn) (*SearchSecretsResponse, error) {
	rsp, err := c.SearchSecrets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchSecretsResponse(rsp)
}

// DeleteSecretWithResponse request returning *DeleteSecretResponse
func (c *ClientWithResponses) DeleteSecretWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteSecretResponse, error) {
	rsp, err := c.DeleteSecret(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecretResponse(rsp)
}

// GetSecretWithResponse request returning *GetSecretResponse
func (c *ClientWithResponses) GetSecretWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSecretResponse, error) {
	rsp, err := c.GetSecret(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecretResponse(rsp)
}

// UpdateSecretWithBodyWithResponse request with arbitrary body returning *UpdateSecretResponse
func (c *ClientWithResponses) UpdateSecretWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSecretResponse, error) {
	rsp, err := c.UpdateSecretWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSecretResponse(rsp)
}

func (c *ClientWithResponses) UpdateSecretWithResponse(ctx context.Context, id string, body UpdateSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSecretResponse, error) {
	rsp, err := c.UpdateSecret(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSecretResponse(rsp)
}

// GetServicesWithResponse request returning *GetServicesResponse
func (c *ClientWithResponses) GetServicesWithResponse(ctx context.Context, params *GetServicesParams, reqEditors ...RequestEditorFn) (*GetServicesResponse, error) {
	rsp, err := c.GetServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesResponse(rsp)
}

// GetServicesCounterWithResponse request returning *GetServicesCounterResponse
func (c *ClientWithResponses) GetServicesCounterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesCounterResponse, error) {
	rsp, err := c.GetServicesCounter(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesCounterResponse(rsp)
}

// GetServicesLabelsWithResponse request returning *GetServicesLabelsResponse
func (c *ClientWithResponses) GetServicesLabelsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesLabelsResponse, error) {
	rsp, err := c.GetServicesLabels(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesLabelsResponse(rsp)
}

// SearchServicesWithResponse request returning *SearchServicesResponse
func (c *ClientWithResponses) SearchServicesWithResponse(ctx context.Context, params *SearchServicesParams, reqEditors ...RequestEditorFn) (*SearchServicesResponse, error) {
	rsp, err := c.SearchServices(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchServicesResponse(rsp)
}

// DeleteServiceWithResponse request returning *DeleteServiceResponse
func (c *ClientWithResponses) DeleteServiceWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteServiceResponse, error) {
	rsp, err := c.DeleteService(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceResponse(rsp)
}

// GetServiceWithResponse request returning *GetServiceResponse
func (c *ClientWithResponses) GetServiceWithResponse(ctx context.Context, id string, params *GetServiceParams, reqEditors ...RequestEditorFn) (*GetServiceResponse, error) {
	rsp, err := c.GetService(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceResponse(rsp)
}

// UpdateServiceMetadataWithBodyWithResponse request with arbitrary body returning *UpdateServiceMetadataResponse
func (c *ClientWithResponses) UpdateServiceMetadataWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceMetadataResponse, error) {
	rsp, err := c.UpdateServiceMetadataWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceMetadataResponse(rsp)
}

func (c *ClientWithResponses) UpdateServiceMetadataWithResponse(ctx context.Context, id string, body UpdateServiceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceMetadataResponse, error) {
	rsp, err := c.UpdateServiceMetadata(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceMetadataResponse(rsp)
}

// OverrideServiceOperationWithBodyWithResponse request with arbitrary body returning *OverrideServiceOperationResponse
func (c *ClientWithResponses) OverrideServiceOperationWithBodyWithResponse(ctx context.Context, id string, params *OverrideServiceOperationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OverrideServiceOperationResponse, error) {
	rsp, err := c.OverrideServiceOperationWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOverrideServiceOperationResponse(rsp)
}

func (c *ClientWithResponses) OverrideServiceOperationWithResponse(ctx context.Context, id string, params *OverrideServiceOperationParams, body OverrideServiceOperationJSONRequestBody, reqEditors ...RequestEditorFn) (*OverrideServiceOperationResponse, error) {
	rsp, err := c.OverrideServiceOperation(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOverrideServiceOperationResponse(rsp)
}

// CreateTestWithBodyWithResponse request with arbitrary body returning *CreateTestResponse
func (c *ClientWithResponses) CreateTestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTestResponse, error) {
	rsp, err := c.CreateTestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTestResponse(rsp)
}

func (c *ClientWithResponses) CreateTestWithResponse(ctx context.Context, body CreateTestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTestResponse, error) {
	rsp, err := c.CreateTest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTestResponse(rsp)
}

// GetTestResultsByServiceWithResponse request returning *GetTestResultsByServiceResponse
func (c *ClientWithResponses) GetTestResultsByServiceWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetTestResultsByServiceResponse, error) {
	rsp, err := c.GetTestResultsByService(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTestResultsByServiceResponse(rsp)
}

// GetTestResultsByServiceCounterWithResponse request returning *GetTestResultsByServiceCounterResponse
func (c *ClientWithResponses) GetTestResultsByServiceCounterWithResponse(ctx context.Context, serviceId string, reqEditors ...RequestEditorFn) (*GetTestResultsByServiceCounterResponse, error) {
	rsp, err := c.GetTestResultsByServiceCounter(ctx, serviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTestResultsByServiceCounterResponse(rsp)
}

// GetTestResultWithResponse request returning *GetTestResultResponse
func (c *ClientWithResponses) GetTestResultWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTestResultResponse, error) {
	rsp, err := c.GetTestResult(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTestResultResponse(rsp)
}

// GetEventsByTestCaseWithResponse request returning *GetEventsByTestCaseResponse
func (c *ClientWithResponses) GetEventsByTestCaseWithResponse(ctx context.Context, id string, testCaseId string, reqEditors ...RequestEditorFn) (*GetEventsByTestCaseResponse, error) {
	rsp, err := c.GetEventsByTestCase(ctx, id, testCaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventsByTestCaseResponse(rsp)
}

// GetMessagesByTestCaseWithResponse request returning *GetMessagesByTestCaseResponse
func (c *ClientWithResponses) GetMessagesByTestCaseWithResponse(ctx context.Context, id string, testCaseId string, reqEditors ...RequestEditorFn) (*GetMessagesByTestCaseResponse, error) {
	rsp, err := c.GetMessagesByTestCase(ctx, id, testCaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMessagesByTestCaseResponse(rsp)
}

// ReportTestCaseResultWithBodyWithResponse request with arbitrary body returning *ReportTestCaseResultResponse
func (c *ClientWithResponses) ReportTestCaseResultWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReportTestCaseResultResponse, error) {
	rsp, err := c.ReportTestCaseResultWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportTestCaseResultResponse(rsp)
}

func (c *ClientWithResponses) ReportTestCaseResultWithResponse(ctx context.Context, id string, body ReportTestCaseResultJSONRequestBody, reqEditors ...RequestEditorFn) (*ReportTestCaseResultResponse, error) {
	rsp, err := c.ReportTestCaseResult(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReportTestCaseResultResponse(rsp)
}

// ParseDownloadArtifactResponse parses an HTTP response from a DownloadArtifactWithResponse call
func ParseDownloadArtifactResponse(rsp *http.Response) (*DownloadArtifactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadArtifactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUploadArtifactResponse parses an HTTP response from a UploadArtifactWithResponse call
func ParseUploadArtifactResponse(rsp *http.Response) (*UploadArtifactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadArtifactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExportSnapshotResponse parses an HTTP response from a ExportSnapshotWithResponse call
func ParseExportSnapshotResponse(rsp *http.Response) (*ExportSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest openapi_types.File
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFeaturesConfigResponse parses an HTTP response from a GetFeaturesConfigWithResponse call
func ParseGetFeaturesConfigResponse(rsp *http.Response) (*GetFeaturesConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeaturesConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseImportSnapshotResponse parses an HTTP response from a ImportSnapshotWithResponse call
func ParseImportSnapshotResponse(rsp *http.Response) (*ImportSnapshotResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportSnapshotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetImportJobsResponse parses an HTTP response from a GetImportJobsWithResponse call
func ParseGetImportJobsResponse(rsp *http.Response) (*GetImportJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImportJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ImportJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateImportJobResponse parses an HTTP response from a CreateImportJobWithResponse call
func ParseCreateImportJobResponse(rsp *http.Response) (*CreateImportJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateImportJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ImportJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetImportJobCounterResponse parses an HTTP response from a GetImportJobCounterWithResponse call
func ParseGetImportJobCounterResponse(rsp *http.Response) (*GetImportJobCounterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImportJobCounterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Counter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteImportJobResponse parses an HTTP response from a DeleteImportJobWithResponse call
func ParseDeleteImportJobResponse(rsp *http.Response) (*DeleteImportJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteImportJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetImportJobResponse parses an HTTP response from a GetImportJobWithResponse call
func ParseGetImportJobResponse(rsp *http.Response) (*GetImportJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetImportJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImportJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateImportJobResponse parses an HTTP response from a UpdateImportJobWithResponse call
func ParseUpdateImportJobResponse(rsp *http.Response) (*UpdateImportJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateImportJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImportJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActivateImportJobResponse parses an HTTP response from a ActivateImportJobWithResponse call
func ParseActivateImportJobResponse(rsp *http.Response) (*ActivateImportJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivateImportJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImportJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStartImportJobResponse parses an HTTP response from a StartImportJobWithResponse call
func ParseStartImportJobResponse(rsp *http.Response) (*StartImportJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartImportJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImportJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStopImportJobResponse parses an HTTP response from a StopImportJobWithResponse call
func ParseStopImportJobResponse(rsp *http.Response) (*StopImportJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StopImportJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImportJob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetKeycloakConfigResponse parses an HTTP response from a GetKeycloakConfigWithResponse call
func ParseGetKeycloakConfigResponse(rsp *http.Response) (*GetKeycloakConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeycloakConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeycloakConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConformanceMetricsAggregationResponse parses an HTTP response from a GetConformanceMetricsAggregationWithResponse call
func ParseGetConformanceMetricsAggregationResponse(rsp *http.Response) (*GetConformanceMetricsAggregationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConformanceMetricsAggregationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WeightedMetricValue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServiceTestConformanceMetricResponse parses an HTTP response from a GetServiceTestConformanceMetricWithResponse call
func ParseGetServiceTestConformanceMetricResponse(rsp *http.Response) (*GetServiceTestConformanceMetricResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceTestConformanceMetricResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestConformanceMetric
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAggregatedInvocationsStatsResponse parses an HTTP response from a GetAggregatedInvocationsStatsWithResponse call
func ParseGetAggregatedInvocationsStatsResponse(rsp *http.Response) (*GetAggregatedInvocationsStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAggregatedInvocationsStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DailyInvocationStatistic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLatestAggregatedInvocationsStatsResponse parses an HTTP response from a GetLatestAggregatedInvocationsStatsWithResponse call
func ParseGetLatestAggregatedInvocationsStatsResponse(rsp *http.Response) (*GetLatestAggregatedInvocationsStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestAggregatedInvocationsStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CounterMap
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopIvnocationsStatsByDayResponse parses an HTTP response from a GetTopIvnocationsStatsByDayWithResponse call
func ParseGetTopIvnocationsStatsByDayResponse(rsp *http.Response) (*GetTopIvnocationsStatsByDayResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopIvnocationsStatsByDayResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DailyInvocationStatistic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInvocationStatsByServiceResponse parses an HTTP response from a GetInvocationStatsByServiceWithResponse call
func ParseGetInvocationStatsByServiceResponse(rsp *http.Response) (*GetInvocationStatsByServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvocationStatsByServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DailyInvocationStatistic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetLatestTestResultsResponse parses an HTTP response from a GetLatestTestResultsWithResponse call
func ParseGetLatestTestResultsResponse(rsp *http.Response) (*GetLatestTestResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatestTestResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TestResultSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourcesByServiceResponse parses an HTTP response from a GetResourcesByServiceWithResponse call
func ParseGetResourcesByServiceResponse(rsp *http.Response) (*GetResourcesByServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcesByServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSecretsResponse parses an HTTP response from a GetSecretsWithResponse call
func ParseGetSecretsResponse(rsp *http.Response) (*GetSecretsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Secret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSecretResponse parses an HTTP response from a CreateSecretWithResponse call
func ParseCreateSecretResponse(rsp *http.Response) (*CreateSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Secret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetSecretsCounterResponse parses an HTTP response from a GetSecretsCounterWithResponse call
func ParseGetSecretsCounterResponse(rsp *http.Response) (*GetSecretsCounterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecretsCounterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Counter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchSecretsResponse parses an HTTP response from a SearchSecretsWithResponse call
func ParseSearchSecretsResponse(rsp *http.Response) (*SearchSecretsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Secret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteSecretResponse parses an HTTP response from a DeleteSecretWithResponse call
func ParseDeleteSecretResponse(rsp *http.Response) (*DeleteSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetSecretResponse parses an HTTP response from a GetSecretWithResponse call
func ParseGetSecretResponse(rsp *http.Response) (*GetSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Secret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSecretResponse parses an HTTP response from a UpdateSecretWithResponse call
func ParseUpdateSecretResponse(rsp *http.Response) (*UpdateSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Secret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServicesResponse parses an HTTP response from a GetServicesWithResponse call
func ParseGetServicesResponse(rsp *http.Response) (*GetServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServicesCounterResponse parses an HTTP response from a GetServicesCounterWithResponse call
func ParseGetServicesCounterResponse(rsp *http.Response) (*GetServicesCounterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesCounterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Counter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetServicesLabelsResponse parses an HTTP response from a GetServicesLabelsWithResponse call
func ParseGetServicesLabelsResponse(rsp *http.Response) (*GetServicesLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LabelsMap
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchServicesResponse parses an HTTP response from a SearchServicesWithResponse call
func ParseSearchServicesResponse(rsp *http.Response) (*SearchServicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchServicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Service
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteServiceResponse parses an HTTP response from a DeleteServiceWithResponse call
func ParseDeleteServiceResponse(rsp *http.Response) (*DeleteServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetServiceResponse parses an HTTP response from a GetServiceWithResponse call
func ParseGetServiceResponse(rsp *http.Response) (*GetServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateServiceMetadataResponse parses an HTTP response from a UpdateServiceMetadataWithResponse call
func ParseUpdateServiceMetadataResponse(rsp *http.Response) (*UpdateServiceMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOverrideServiceOperationResponse parses an HTTP response from a OverrideServiceOperationWithResponse call
func ParseOverrideServiceOperationResponse(rsp *http.Response) (*OverrideServiceOperationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OverrideServiceOperationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateTestResponse parses an HTTP response from a CreateTestWithResponse call
func ParseCreateTestResponse(rsp *http.Response) (*CreateTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TestResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetTestResultsByServiceResponse parses an HTTP response from a GetTestResultsByServiceWithResponse call
func ParseGetTestResultsByServiceResponse(rsp *http.Response) (*GetTestResultsByServiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTestResultsByServiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TestResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTestResultsByServiceCounterResponse parses an HTTP response from a GetTestResultsByServiceCounterWithResponse call
func ParseGetTestResultsByServiceCounterResponse(rsp *http.Response) (*GetTestResultsByServiceCounterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTestResultsByServiceCounterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Counter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTestResultResponse parses an HTTP response from a GetTestResultWithResponse call
func ParseGetTestResultResponse(rsp *http.Response) (*GetTestResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTestResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEventsByTestCaseResponse parses an HTTP response from a GetEventsByTestCaseWithResponse call
func ParseGetEventsByTestCaseResponse(rsp *http.Response) (*GetEventsByTestCaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventsByTestCaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UnidirectionalEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMessagesByTestCaseResponse parses an HTTP response from a GetMessagesByTestCaseWithResponse call
func ParseGetMessagesByTestCaseResponse(rsp *http.Response) (*GetMessagesByTestCaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMessagesByTestCaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RequestResponsePair
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReportTestCaseResultResponse parses an HTTP response from a ReportTestCaseResultWithResponse call
func ParseReportTestCaseResultResponse(rsp *http.Response) (*ReportTestCaseResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReportTestCaseResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TestCaseResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
